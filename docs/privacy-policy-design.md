# LeoFitTech ê°œì¸ì •ë³´ ë³´í˜¸ ì •ì±… ì„¤ê³„ ë¬¸ì„œ

## ğŸ“‹ ë¬¸ì„œ ê°œìš”

### ëª©ì 

LeoFitTech ìƒë‹´ ì‹œìŠ¤í…œì—ì„œ ìˆ˜ì§‘, ì²˜ë¦¬, ë³´ê´€í•˜ëŠ” ê°œì¸ì •ë³´ì— ëŒ€í•œ ì²´ê³„ì ì¸ ë³´í˜¸ ë°©ì•ˆê³¼ ì •ì±…ì„ ì •ì˜í•©ë‹ˆë‹¤.

### ë²”ìœ„

- ì›¹ì‚¬ì´íŠ¸ ë°©ë¬¸ì ì •ë³´
- ìƒë‹´ ì‹ ì²­ì ê°œì¸ì •ë³´
- ë§ˆì¼€íŒ… ë° ë¶„ì„ ë°ì´í„°
- ì¿ í‚¤ ë° ì¶”ì  ê¸°ìˆ 

### ë²•ì  ê·¼ê±°

- ê°œì¸ì •ë³´ë³´í˜¸ë²• (í•œêµ­)
- ì •ë³´í†µì‹ ë§ ì´ìš©ì´‰ì§„ ë° ì •ë³´ë³´í˜¸ ë“±ì— ê´€í•œ ë²•ë¥ 
- GDPR (EU ë°©ë¬¸ì ëŒ€ì‘)

---

## ğŸ” ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš© ë‚´ì—­

### 1. ìˆ˜ì§‘í•˜ëŠ” ê°œì¸ì •ë³´ í•­ëª©

#### 1.1 í•„ìˆ˜ ìˆ˜ì§‘ ì •ë³´

| ìˆ˜ì§‘ í•­ëª©   | ìˆ˜ì§‘ ë°©ë²•    | ìˆ˜ì§‘ ëª©ì                    | ë³´ê´€ ê¸°ê°„ |
| ----------- | ------------ | --------------------------- | --------- |
| ì„±ëª…        | ìƒë‹´ ì‹ ì²­ í¼ | ìƒë‹´ ì„œë¹„ìŠ¤ ì œê³µ, ë³¸ì¸ í™•ì¸ | 3ë…„       |
| ì „í™”ë²ˆí˜¸    | ìƒë‹´ ì‹ ì²­ í¼ | ìƒë‹´ ì—°ë½, ì„œë¹„ìŠ¤ ì•ˆë‚´      | 3ë…„       |
| ì´ë©”ì¼ ì£¼ì†Œ | ìƒë‹´ ì‹ ì²­ í¼ | ìƒë‹´ ê²°ê³¼ ë°œì†¡, ì„œë¹„ìŠ¤ ì•ˆë‚´ | 3ë…„       |

#### 1.2 ì„ íƒ ìˆ˜ì§‘ ì •ë³´

| ìˆ˜ì§‘ í•­ëª©     | ìˆ˜ì§‘ ë°©ë²•    | ìˆ˜ì§‘ ëª©ì                | ë³´ê´€ ê¸°ê°„ |
| ------------- | ------------ | ----------------------- | --------- |
| íšŒì‚¬ëª…        | ìƒë‹´ ì‹ ì²­ í¼ | ë§ì¶¤í˜• ìƒë‹´ ì„œë¹„ìŠ¤ ì œê³µ | 3ë…„       |
| í”„ë¡œì íŠ¸ ì„¤ëª… | ìƒë‹´ ì‹ ì²­ í¼ | ìƒë‹´ í’ˆì§ˆ í–¥ìƒ          | 3ë…„       |
| ì˜ˆì‚° ë²”ìœ„     | ìƒë‹´ ì‹ ì²­ í¼ | ì í•©í•œ ì†”ë£¨ì…˜ ì œì•ˆ      | 3ë…„       |

#### 1.3 ìë™ ìˆ˜ì§‘ ì •ë³´

| ìˆ˜ì§‘ í•­ëª©     | ìˆ˜ì§‘ ë°©ë²•    | ìˆ˜ì§‘ ëª©ì              | ë³´ê´€ ê¸°ê°„ |
| ------------- | ------------ | --------------------- | --------- |
| IP ì£¼ì†Œ       | ì„œë²„ ë¡œê·¸    | ë³´ì•ˆ, í†µê³„ ë¶„ì„       | 1ë…„       |
| ë¸Œë¼ìš°ì € ì •ë³´ | User-Agent   | ì„œë¹„ìŠ¤ ìµœì í™”         | 1ë…„       |
| ì ‘ì† ì‹œê°„     | ì„œë²„ ë¡œê·¸    | ì„œë¹„ìŠ¤ ì´ìš© íŒ¨í„´ ë¶„ì„ | 1ë…„       |
| í˜ì´ì§€ ê²½ë¡œ   | ì›¹ ë¶„ì„ ë„êµ¬ | ì‚¬ìš©ì ê²½í—˜ ê°œì„       | 1ë…„       |
| ì¿ í‚¤ ID       | ë¸Œë¼ìš°ì €     | ë§ì¶¤í˜• ì„œë¹„ìŠ¤ ì œê³µ    | 1ë…„       |

### 2. ìˆ˜ì§‘ ë° ì´ìš© ëª©ì 

#### 2.1 ìƒë‹´ ì„œë¹„ìŠ¤ ì œê³µ

- ê³ ê° ë¬¸ì˜ ì ‘ìˆ˜ ë° ì²˜ë¦¬
- ë§ì¶¤í˜• ìƒë‹´ ì„œë¹„ìŠ¤ ì œê³µ
- ê²¬ì ì„œ ë° ì œì•ˆì„œ ë°œì†¡
- í”„ë¡œì íŠ¸ ì§„í–‰ ìƒí™© ì•ˆë‚´

#### 2.2 ì„œë¹„ìŠ¤ ê°œì„ 

- ì›¹ì‚¬ì´íŠ¸ ì´ìš© íŒ¨í„´ ë¶„ì„
- ì„œë¹„ìŠ¤ í’ˆì§ˆ í–¥ìƒ
- ì‹ ê·œ ì„œë¹„ìŠ¤ ê°œë°œ
- ì‚¬ìš©ì ê²½í—˜ ìµœì í™”

#### 2.3 ë§ˆì¼€íŒ… ë° ê´‘ê³ 

- ë§ì¶¤í˜• ê´‘ê³  ì œê³µ
- ì„œë¹„ìŠ¤ ì•ˆë‚´ ì´ë©”ì¼ ë°œì†¡
- ì´ë²¤íŠ¸ ë° í”„ë¡œëª¨ì…˜ ì•ˆë‚´
- ë§Œì¡±ë„ ì¡°ì‚¬

#### 2.4 ë²•ì  ì˜ë¬´ ì´í–‰

- ì „ììƒê±°ë˜ë²•ìƒ ê¸°ë¡ ë³´ê´€
- ì„¸ë¬´ ê´€ë ¨ ê¸°ë¡ ìœ ì§€
- ë¶„ìŸ í•´ê²° ë° ë²•ì  ëŒ€ì‘

---

## ğŸ›¡ï¸ ê°œì¸ì •ë³´ ë³´í˜¸ ê¸°ìˆ ì  ì¡°ì¹˜

### 1. ë°ì´í„° ì•”í˜¸í™”

#### 1.1 ì „ì†¡ ì¤‘ ì•”í˜¸í™”

```typescript
// HTTPS ê°•ì œ ì ìš©
const securityHeaders = {
  "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
  "X-Content-Type-Options": "nosniff",
  "X-Frame-Options": "DENY",
  "X-XSS-Protection": "1; mode=block",
  "Referrer-Policy": "strict-origin-when-cross-origin",
};
```

#### 1.2 ì €ì¥ ì‹œ ì•”í˜¸í™”

```typescript
// ë¯¼ê° ì •ë³´ ì•”í˜¸í™” ì €ì¥
import crypto from "crypto";

export class PersonalDataEncryption {
  private static readonly ALGORITHM = "aes-256-gcm";
  private static readonly KEY = process.env.ENCRYPTION_KEY;

  static encrypt(text: string): {
    encrypted: string;
    iv: string;
    tag: string;
  } {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.ALGORITHM, this.KEY);

    let encrypted = cipher.update(text, "utf8", "hex");
    encrypted += cipher.final("hex");

    return {
      encrypted,
      iv: iv.toString("hex"),
      tag: cipher.getAuthTag().toString("hex"),
    };
  }

  static decrypt(encryptedData: {
    encrypted: string;
    iv: string;
    tag: string;
  }): string {
    const decipher = crypto.createDecipher(this.ALGORITHM, this.KEY);
    decipher.setAuthTag(Buffer.from(encryptedData.tag, "hex"));

    let decrypted = decipher.update(encryptedData.encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");

    return decrypted;
  }
}
```

### 2. ì ‘ê·¼ ì œì–´

#### 2.1 ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ì œí•œ

```sql
-- ê°œì¸ì •ë³´ ì ‘ê·¼ ê¶Œí•œ ê´€ë¦¬
CREATE ROLE privacy_officer;
CREATE ROLE customer_service;
CREATE ROLE developer;

-- ì—­í• ë³„ ê¶Œí•œ ë¶€ì—¬
GRANT SELECT, UPDATE ON consultations TO privacy_officer;
GRANT SELECT ON consultations TO customer_service;
GRANT SELECT ON analytics_events TO developer;

-- ê°œì¸ì •ë³´ ë§ˆìŠ¤í‚¹ ë·° ìƒì„±
CREATE VIEW consultations_masked AS
SELECT
  id,
  consultation_number,
  type,
  status,
  CASE
    WHEN CURRENT_USER = 'privacy_officer' THEN contact_name
    ELSE SUBSTR(contact_name, 1, 1) || '***'
  END as contact_name,
  CASE
    WHEN CURRENT_USER = 'privacy_officer' THEN contact_phone
    ELSE SUBSTR(contact_phone, 1, 3) || '-****-' || SUBSTR(contact_phone, -4)
  END as contact_phone,
  CASE
    WHEN CURRENT_USER = 'privacy_officer' THEN contact_email
    ELSE SUBSTR(contact_email, 1, 3) || '***@' || SUBSTR(contact_email, INSTR(contact_email, '@') + 1)
  END as contact_email,
  created_at,
  updated_at
FROM consultations;
```

#### 2.2 API ë ˆë²¨ ì ‘ê·¼ ì œì–´

```typescript
// ê°œì¸ì •ë³´ ì ‘ê·¼ ê¶Œí•œ ë¯¸ë“¤ì›¨ì–´
export function withPrivacyControl(
  requiredRole: "admin" | "privacy_officer" | "customer_service"
) {
  return function (handler: NextApiHandler): NextApiHandler {
    return async (req: NextApiRequest, res: NextApiResponse) => {
      // ì¸ì¦ í™•ì¸
      const session = await getSession(req);
      if (!session) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      // ê¶Œí•œ í™•ì¸
      if (!hasPrivacyAccess(session.user, requiredRole)) {
        logger.securityEvent("unauthorized_privacy_access", "high", req, {
          userId: session.user.id,
          requiredRole,
          userRole: session.user.role,
        });
        return res.status(403).json({ error: "Insufficient privacy access" });
      }

      // ê°œì¸ì •ë³´ ì ‘ê·¼ ë¡œê·¸
      logger.businessEvent("privacy_data_access", "personal_data", {
        userId: session.user.id,
        userRole: session.user.role,
        method: req.method,
        url: req.url,
      });

      return handler(req, res);
    };
  };
}
```

### 3. ë°ì´í„° ìµœì†Œí™”

#### 3.1 ìˆ˜ì§‘ ë°ì´í„° ìµœì†Œí™”

```typescript
// í•„ìˆ˜/ì„ íƒ í•„ë“œ ëª…í™•í•œ êµ¬ë¶„
export interface ConsultationFormValidation {
  required: {
    name: string;
    phone: string;
    email: string;
  };
  optional: {
    company?: string;
    projectDescription?: string;
    budget?: string;
  };
}

// ë°ì´í„° ìˆ˜ì§‘ ë™ì˜ ê´€ë¦¬
export interface ConsentSettings {
  essential: boolean; // í•„ìˆ˜ (ì„œë¹„ìŠ¤ ì œê³µìš©)
  marketing: boolean; // ë§ˆì¼€íŒ… í™œìš© ë™ì˜
  analytics: boolean; // ë¶„ì„ ëª©ì  ë™ì˜
  thirdParty: boolean; // ì œ3ì ì œê³µ ë™ì˜
}
```

#### 3.2 ë°ì´í„° ìµëª…í™”

```typescript
// ê°œì¸ì •ë³´ ìµëª…í™” ì²˜ë¦¬
export class DataAnonymizer {
  static anonymizeForAnalytics(data: ConsultationData): AnonymizedData {
    return {
      id: data.id,
      type: data.type,
      serviceType: data.serviceType,
      projectSize: data.projectSize,
      budget: data.budget,
      region: this.getRegionFromIP(data.ipAddress), // IPë¥¼ ì§€ì—­ìœ¼ë¡œ ë³€í™˜
      deviceType: this.getDeviceType(data.userAgent),
      submittedAt: data.submittedAt,
      // ê°œì¸ì‹ë³„ì •ë³´ ì œê±°
    };
  }

  static pseudonymize(personalId: string): string {
    // ê°œì¸ì •ë³´ë¥¼ ê°€ëª…ì²˜ë¦¬
    return crypto
      .createHash("sha256")
      .update(personalId + process.env.PSEUDONYM_SALT)
      .digest("hex")
      .substring(0, 16);
  }
}
```

---

## ğŸ“Š ê°œì¸ì •ë³´ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬

### 1. ìˆ˜ì§‘ ë‹¨ê³„

#### 1.1 ìˆ˜ì§‘ ë™ì˜ í”„ë¡œì„¸ìŠ¤

```typescript
// ë™ì˜ ìˆ˜ì§‘ ì»´í¬ë„ŒíŠ¸
export const PrivacyConsentForm: React.FC = () => {
  return (
    <div className="privacy-consent">
      <h3>ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš© ë™ì˜</h3>

      {/* í•„ìˆ˜ ë™ì˜ */}
      <div className="consent-item required">
        <input
          type="checkbox"
          id="essential"
          required
          onChange={handleConsentChange}
        />
        <label htmlFor="essential">
          [í•„ìˆ˜] ìƒë‹´ ì„œë¹„ìŠ¤ ì œê³µì„ ìœ„í•œ ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš©
        </label>
        <button onClick={() => showDetails("essential")}>ìƒì„¸ë³´ê¸°</button>
      </div>

      {/* ì„ íƒ ë™ì˜ */}
      <div className="consent-item optional">
        <input type="checkbox" id="marketing" onChange={handleConsentChange} />
        <label htmlFor="marketing">
          [ì„ íƒ] ë§ˆì¼€íŒ… í™œìš©ì„ ìœ„í•œ ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš©
        </label>
        <button onClick={() => showDetails("marketing")}>ìƒì„¸ë³´ê¸°</button>
      </div>

      <div className="consent-item optional">
        <input type="checkbox" id="analytics" onChange={handleConsentChange} />
        <label htmlFor="analytics">
          [ì„ íƒ] ì„œë¹„ìŠ¤ ê°œì„ ì„ ìœ„í•œ ì´ìš© í†µê³„ ë¶„ì„
        </label>
        <button onClick={() => showDetails("analytics")}>ìƒì„¸ë³´ê¸°</button>
      </div>
    </div>
  );
};
```

#### 1.2 ë™ì˜ ì´ë ¥ ê´€ë¦¬

```typescript
// ë™ì˜ ì´ë ¥ ì €ì¥
interface ConsentRecord {
  userId: string;
  consentType: "essential" | "marketing" | "analytics" | "thirdParty";
  consentGiven: boolean;
  consentDate: string;
  ipAddress: string;
  userAgent: string;
  privacyPolicyVersion: string;
}

export async function recordConsent(
  userId: string,
  consents: ConsentSettings,
  metadata: { ip: string; userAgent: string }
): Promise<void> {
  const records: ConsentRecord[] = Object.entries(consents).map(
    ([type, given]) => ({
      userId,
      consentType: type as keyof ConsentSettings,
      consentGiven: given,
      consentDate: new Date().toISOString(),
      ipAddress: metadata.ip,
      userAgent: metadata.userAgent,
      privacyPolicyVersion: CURRENT_PRIVACY_POLICY_VERSION,
    })
  );

  await supabase.from("consent_records").insert(records);
}
```

### 2. ë³´ê´€ ë‹¨ê³„

#### 2.1 ë³´ê´€ ê¸°ê°„ ê´€ë¦¬

```typescript
// ê°œì¸ì •ë³´ ë³´ê´€ ê¸°ê°„ ì„¤ì •
export const RETENTION_PERIODS = {
  CONSULTATION_DATA: 3 * 365, // 3ë…„ (ì¼)
  MARKETING_DATA: 2 * 365, // 2ë…„
  WEB_LOGS: 1 * 365, // 1ë…„
  CONSENT_RECORDS: 5 * 365, // 5ë…„ (ë²•ì • ì˜ë¬´)
  WITHDRAWAL_RECORDS: 5 * 365, // 5ë…„
};

// ìë™ ì‚­ì œ ìŠ¤ì¼€ì¤„ëŸ¬
export class DataRetentionScheduler {
  static async scheduleDataDeletion(): Promise<void> {
    const cutoffDates = {
      consultation: new Date(
        Date.now() - RETENTION_PERIODS.CONSULTATION_DATA * 24 * 60 * 60 * 1000
      ),
      marketing: new Date(
        Date.now() - RETENTION_PERIODS.MARKETING_DATA * 24 * 60 * 60 * 1000
      ),
      webLogs: new Date(
        Date.now() - RETENTION_PERIODS.WEB_LOGS * 24 * 60 * 60 * 1000
      ),
    };

    // ë³´ê´€ ê¸°ê°„ ì´ˆê³¼ ë°ì´í„° ì‹ë³„
    const expiredData = await this.identifyExpiredData(cutoffDates);

    // ì•ˆì „í•œ ì‚­ì œ ì‹¤í–‰
    await this.safeDeleteData(expiredData);

    // ì‚­ì œ ì´ë ¥ ê¸°ë¡
    await this.recordDeletionHistory(expiredData);
  }

  private static async safeDeleteData(
    expiredData: ExpiredDataSummary
  ): Promise<void> {
    // 1. ë°±ì—… ìƒì„±
    await this.createDeletionBackup(expiredData);

    // 2. ë‹¨ê³„ì  ì‚­ì œ (ì—°ê´€ ë°ì´í„°ë¶€í„°)
    await this.deleteRelatedData(expiredData);

    // 3. ë©”ì¸ ë°ì´í„° ì‚­ì œ
    await this.deleteMainData(expiredData);

    // 4. ì‚­ì œ í™•ì¸
    await this.verifyDeletion(expiredData);
  }
}
```

### 3. íŒŒê¸° ë‹¨ê³„

#### 3.1 ê°œì¸ì •ë³´ íŒŒê¸° ì ˆì°¨

```typescript
// ê°œì¸ì •ë³´ íŒŒê¸° í”„ë¡œì„¸ìŠ¤
export class PersonalDataDestruction {
  static async processDataDestruction(
    destructionRequest: DestructionRequest
  ): Promise<DestructionResult> {
    const startTime = Date.now();

    try {
      // 1. íŒŒê¸° ëŒ€ìƒ ê²€ì¦
      const validationResult = await this.validateDestructionRequest(
        destructionRequest
      );
      if (!validationResult.isValid) {
        throw new Error(
          `Invalid destruction request: ${validationResult.reason}`
        );
      }

      // 2. íŒŒê¸° ì „ ë°±ì—… (ë²•ì  ìš”êµ¬ì‚¬í•­)
      const backupResult = await this.createDestructionBackup(
        destructionRequest
      );

      // 3. ë°ì´í„° ì™„ì „ ì‚­ì œ
      const deletionResult = await this.performSecureDeletion(
        destructionRequest
      );

      // 4. íŒŒê¸° ì¦ëª…ì„œ ìƒì„±
      const certificate = await this.generateDestructionCertificate({
        requestId: destructionRequest.id,
        targetData: destructionRequest.targetData,
        destructionMethod: "secure_overwrite",
        executedBy: destructionRequest.executedBy,
        executedAt: new Date().toISOString(),
        verificationHash: deletionResult.verificationHash,
      });

      return {
        success: true,
        certificate,
        duration: Date.now() - startTime,
        destroyedRecords: deletionResult.recordCount,
      };
    } catch (error) {
      logger.securityEvent("data_destruction_failed", "high", undefined, {
        destructionRequestId: destructionRequest.id,
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
        },
      });

      throw error;
    }
  }
}
```

---

## ğŸ” ê°œì¸ì •ë³´ ì—´ëŒ, ì •ì •, ì‚­ì œ ê¶Œë¦¬ ë³´ì¥

### 1. ê°œì¸ì •ë³´ ì—´ëŒê¶Œ

#### 1.1 ë³¸ì¸ í™•ì¸ ì ˆì°¨

```typescript
// ë³¸ì¸ í™•ì¸ API
export async function verifyIdentityForDataAccess(
  req: NextApiRequest,
  res: NextApiResponse
): Promise<void> {
  const { email, phone, verificationCode } = req.body;

  // 1. ì´ë©”ì¼/ì „í™”ë²ˆí˜¸ë¡œ ê¸°ë³¸ í™•ì¸
  const user = await findUserByContact(email, phone);
  if (!user) {
    return res.status(404).json({ error: "User not found" });
  }

  // 2. ì¶”ê°€ ì¸ì¦ (SMS/ì´ë©”ì¼ ì¸ì¦)
  const isCodeValid = await verifyAuthenticationCode(user.id, verificationCode);
  if (!isCodeValid) {
    // ì‹¤íŒ¨ ë¡œê·¸ ê¸°ë¡
    logger.securityEvent("identity_verification_failed", "medium", req, {
      userId: user.id,
      verificationMethod: "sms_email",
    });
    return res.status(401).json({ error: "Invalid verification code" });
  }

  // 3. ì„ì‹œ ì ‘ê·¼ í† í° ìƒì„±
  const accessToken = generateDataAccessToken(user.id, "1hour");

  res.json({
    success: true,
    accessToken,
    expiresIn: 3600,
  });
}
```

#### 1.2 ê°œì¸ì •ë³´ ì—´ëŒ ì œê³µ

```typescript
// ê°œì¸ì •ë³´ ì—´ëŒ API
export async function getPersonalDataSummary(
  userId: string,
  accessToken: string
): Promise<PersonalDataSummary> {
  // í† í° ê²€ì¦
  const tokenValid = await validateDataAccessToken(accessToken, userId);
  if (!tokenValid) {
    throw new Error("Invalid or expired access token");
  }

  // ê°œì¸ì •ë³´ ìˆ˜ì§‘
  const personalData = await collectUserPersonalData(userId);

  // ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹ (í•„ìš”í•œ ê²½ìš°)
  const maskedData = maskSensitiveFields(personalData);

  // ì—´ëŒ ê¸°ë¡
  logger.businessEvent("personal_data_accessed", "user_request", {
    userId,
    accessMethod: "self_service_portal",
    dataTypes: Object.keys(personalData),
  });

  return {
    basicInfo: maskedData.basicInfo,
    consultationHistory: maskedData.consultations,
    consentHistory: personalData.consents,
    dataCollectionSources: personalData.sources,
    retentionStatus: personalData.retention,
    marketingPreferences: personalData.marketing,
  };
}
```

### 2. ê°œì¸ì •ë³´ ì •ì •ê¶Œ

#### 2.1 ì •ì • ìš”ì²­ ì²˜ë¦¬

```typescript
// ê°œì¸ì •ë³´ ì •ì • API
export async function requestPersonalDataCorrection(
  userId: string,
  correctionRequest: DataCorrectionRequest
): Promise<CorrectionResult> {
  // 1. ì •ì • ê°€ëŠ¥ í•„ë“œ í™•ì¸
  const editableFields = await getEditableFields(userId);
  const invalidFields = correctionRequest.fields.filter(
    (field) => !editableFields.includes(field.name)
  );

  if (invalidFields.length > 0) {
    throw new Error(
      `Cannot modify fields: ${invalidFields.map((f) => f.name).join(", ")}`
    );
  }

  // 2. ë³€ê²½ ì‚¬í•­ ê²€ì¦
  const validationResult = await validateCorrectionData(
    correctionRequest.fields
  );
  if (!validationResult.isValid) {
    throw new Error(`Validation failed: ${validationResult.errors.join(", ")}`);
  }

  // 3. ë³€ê²½ ì´ë ¥ ê¸°ë¡ (ë³€ê²½ ì „ ë°ì´í„° ë°±ì—…)
  const currentData = await getCurrentPersonalData(userId);
  await recordDataChangeHistory({
    userId,
    changeType: "correction",
    previousData: currentData,
    requestedChanges: correctionRequest.fields,
    requestedBy: userId,
    requestedAt: new Date().toISOString(),
  });

  // 4. ë°ì´í„° ì—…ë°ì´íŠ¸
  await updatePersonalData(userId, correctionRequest.fields);

  // 5. ì •ì • ì™„ë£Œ ë¡œê·¸
  logger.businessEvent("personal_data_corrected", "user_request", {
    userId,
    correctedFields: correctionRequest.fields.map((f) => f.name),
    requestId: correctionRequest.id,
  });

  return {
    success: true,
    correctedFields: correctionRequest.fields.map((f) => f.name),
    processedAt: new Date().toISOString(),
  };
}
```

### 3. ê°œì¸ì •ë³´ ì‚­ì œê¶Œ (ìŠí ê¶Œë¦¬)

#### 3.1 ì‚­ì œ ìš”ì²­ ê²€ì¦

```typescript
// ê°œì¸ì •ë³´ ì‚­ì œ ìš”ì²­ ê²€ì¦
export async function validateDeletionRequest(
  userId: string,
  deletionRequest: DeletionRequest
): Promise<DeletionValidationResult> {
  const validationIssues: string[] = [];

  // 1. ë²•ì  ë³´ê´€ ì˜ë¬´ í™•ì¸
  const legalRetentionCheck = await checkLegalRetentionRequirements(userId);
  if (legalRetentionCheck.hasLegalHold) {
    validationIssues.push(
      `Legal retention period not expired: ${legalRetentionCheck.reason}`
    );
  }

  // 2. ì§„í–‰ ì¤‘ì¸ í”„ë¡œì íŠ¸ í™•ì¸
  const activeProjects = await getActiveProjects(userId);
  if (activeProjects.length > 0) {
    validationIssues.push(
      `Cannot delete data while projects are active: ${activeProjects
        .map((p) => p.id)
        .join(", ")}`
    );
  }

  // 3. ê³„ì•½ìƒ ì˜ë¬´ í™•ì¸
  const contractualObligations = await checkContractualObligations(userId);
  if (contractualObligations.hasObligations) {
    validationIssues.push(
      `Contractual obligations exist: ${contractualObligations.details}`
    );
  }

  return {
    canDelete: validationIssues.length === 0,
    issues: validationIssues,
    estimatedDeletionDate:
      validationIssues.length === 0
        ? addDays(new Date(), 30) // 30ì¼ í›„ ì‚­ì œ
        : null,
  };
}
```

#### 3.2 ë‹¨ê³„ì  ì‚­ì œ í”„ë¡œì„¸ìŠ¤

```typescript
// ê°œì¸ì •ë³´ ì‚­ì œ í”„ë¡œì„¸ìŠ¤
export class PersonalDataDeletionProcess {
  static async processUserDeletionRequest(
    userId: string,
    deletionRequest: UserDeletionRequest
  ): Promise<DeletionProcessResult> {
    // 1ë‹¨ê³„: ì‚­ì œ ìš”ì²­ ì ‘ìˆ˜ ë° í™•ì¸
    const requestId = await this.recordDeletionRequest(userId, deletionRequest);

    // 2ë‹¨ê³„: 30ì¼ ìœ ì˜ˆ ê¸°ê°„ (ì² íšŒ ê°€ëŠ¥)
    await this.startGracePeriod(requestId, 30);

    // 3ë‹¨ê³„: ìœ ì˜ˆ ê¸°ê°„ í›„ ì‚­ì œ ì‹¤í–‰
    setTimeout(async () => {
      const isWithdrawn = await this.checkIfRequestWithdrawn(requestId);
      if (!isWithdrawn) {
        await this.executeDeletion(userId, requestId);
      }
    }, 30 * 24 * 60 * 60 * 1000); // 30ì¼

    return {
      requestId,
      status: "grace_period_started",
      gracePeriodEnds: addDays(new Date(), 30),
      canWithdraw: true,
    };
  }

  private static async executeDeletion(
    userId: string,
    requestId: string
  ): Promise<void> {
    try {
      // 1. ì‚­ì œ ì „ ìµœì¢… ë°±ì—…
      await this.createFinalBackup(userId);

      // 2. ì—°ê´€ ë°ì´í„° ì‹ë³„ ë° ì‚­ì œ
      await this.deleteRelatedRecords(userId);

      // 3. ê°œì¸ì •ë³´ ì™„ì „ ì‚­ì œ
      await this.secureDeletePersonalData(userId);

      // 4. ì‚­ì œ ì™„ë£Œ ì¸ì¦ì„œ ìƒì„±
      const certificate = await this.generateDeletionCertificate(
        userId,
        requestId
      );

      // 5. ì‚­ì œ ì™„ë£Œ í†µì§€ (ì‚­ì œëœ ì´ë©”ì¼ì´ ì•„ë‹Œ ë‹¤ë¥¸ ì—°ë½ì²˜ë¡œ)
      await this.notifyDeletionCompletion(userId, certificate);

      logger.businessEvent("personal_data_deleted", "user_request", {
        userId: `deleted_${Date.now()}`, // ìµëª…í™”ëœ ì‹ë³„ì
        requestId,
        deletionMethod: "secure_overwrite",
      });
    } catch (error) {
      logger.error("Personal data deletion failed", {
        userId,
        requestId,
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
        },
      });

      // ì‚­ì œ ì‹¤íŒ¨ ì‹œ ê´€ë¦¬ìì—ê²Œ ì•Œë¦¼
      await this.notifyAdminDeletionFailure(userId, requestId, error);
    }
  }
}
```

---

## ğŸ“ˆ ê°œì¸ì •ë³´ ë³´í˜¸ ëª¨ë‹ˆí„°ë§ ë° ê°ì‚¬

### 1. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

#### 1.1 ê°œì¸ì •ë³´ ì ‘ê·¼ ëª¨ë‹ˆí„°ë§

```typescript
// ê°œì¸ì •ë³´ ì ‘ê·¼ ê°ì‹œ ì‹œìŠ¤í…œ
export class PrivacyAccessMonitor {
  private static suspiciousPatterns = [
    { pattern: "bulk_data_access", threshold: 100 }, // 1ì‹œê°„ ë‚´ 100ê±´ ì´ìƒ ì ‘ê·¼
    {
      pattern: "off_hours_access",
      timeRange: { start: "22:00", end: "06:00" },
    },
    { pattern: "location_anomaly", maxDistance: 1000 }, // 1000km ì´ìƒ ìœ„ì¹˜ ë³€í™”
    { pattern: "failed_authentication", threshold: 5 }, // 5íšŒ ì´ìƒ ì¸ì¦ ì‹¤íŒ¨
  ];

  static async monitorAccess(accessEvent: PrivacyAccessEvent): Promise<void> {
    // 1. ì‹¤ì‹œê°„ íŒ¨í„´ ë¶„ì„
    const anomalies = await this.detectAnomalies(accessEvent);

    // 2. ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ê°ì§€ ì‹œ ê²½ê³ 
    if (anomalies.length > 0) {
      await this.triggerSecurityAlert(accessEvent, anomalies);
    }

    // 3. ì ‘ê·¼ ë¡œê·¸ ê¸°ë¡
    await this.logAccessEvent(accessEvent);
  }

  private static async detectAnomalies(
    event: PrivacyAccessEvent
  ): Promise<SecurityAnomaly[]> {
    const anomalies: SecurityAnomaly[] = [];

    // ëŒ€ëŸ‰ ì ‘ê·¼ ê°ì§€
    const recentAccess = await this.getRecentAccessCount(event.userId, "1hour");
    if (recentAccess > 100) {
      anomalies.push({
        type: "bulk_data_access",
        severity: "high",
        details: `${recentAccess} records accessed in 1 hour`,
      });
    }

    // ë¹„ì •ìƒ ì‹œê°„ ì ‘ê·¼ ê°ì§€
    const accessHour = new Date(event.timestamp).getHours();
    if (accessHour >= 22 || accessHour <= 6) {
      anomalies.push({
        type: "off_hours_access",
        severity: "medium",
        details: `Access at ${accessHour}:00`,
      });
    }

    return anomalies;
  }
}
```

#### 1.2 ìë™í™”ëœ ë³´ì•ˆ ëŒ€ì‘

```typescript
// ìë™ ë³´ì•ˆ ëŒ€ì‘ ì‹œìŠ¤í…œ
export class AutomatedSecurityResponse {
  static async handleSecurityEvent(
    event: SecurityEvent,
    severity: "low" | "medium" | "high" | "critical"
  ): Promise<void> {
    switch (severity) {
      case "critical":
        // ì¦‰ì‹œ ê³„ì • ì ê¸ˆ ë° ê´€ë¦¬ì ì•Œë¦¼
        await this.lockUserAccount(event.userId);
        await this.notifySecurityTeam(event, "immediate");
        await this.createIncidentTicket(event);
        break;

      case "high":
        // ì¶”ê°€ ì¸ì¦ ìš”êµ¬ ë° ê°ì‹œ ê°•í™”
        await this.requireAdditionalAuth(event.userId);
        await this.increaseMonitoringLevel(event.userId);
        await this.notifySecurityTeam(event, "urgent");
        break;

      case "medium":
        // ê²½ê³  ë¡œê·¸ ë° ì¼ì¼ ë³´ê³ ì„œ í¬í•¨
        await this.logSecurityWarning(event);
        await this.addToDailyReport(event);
        break;

      case "low":
        // ë¡œê·¸ ê¸°ë¡ë§Œ
        await this.logSecurityEvent(event);
        break;
    }
  }
}
```

### 2. ì •ê¸° ê°ì‚¬

#### 2.1 ê°œì¸ì •ë³´ ë³´í˜¸ ê°ì‚¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

```typescript
// ì •ê¸° ê°ì‚¬ ìë™í™”
export class PrivacyComplianceAudit {
  private static auditChecklist = [
    "data_collection_consent_verification",
    "retention_period_compliance",
    "access_control_effectiveness",
    "encryption_status_check",
    "deletion_request_processing",
    "breach_response_readiness",
    "staff_training_completion",
    "vendor_compliance_status",
  ];

  static async conductMonthlyAudit(): Promise<AuditReport> {
    const auditResults: AuditResult[] = [];

    for (const checkItem of this.auditChecklist) {
      const result = await this.performAuditCheck(checkItem);
      auditResults.push(result);
    }

    const report = this.generateAuditReport(auditResults);
    await this.saveAuditReport(report);
    await this.notifyStakeholders(report);

    return report;
  }

  private static async performAuditCheck(
    checkItem: string
  ): Promise<AuditResult> {
    switch (checkItem) {
      case "data_collection_consent_verification":
        return await this.auditConsentRecords();

      case "retention_period_compliance":
        return await this.auditDataRetention();

      case "access_control_effectiveness":
        return await this.auditAccessControls();

      default:
        throw new Error(`Unknown audit check: ${checkItem}`);
    }
  }
}
```

---

## ğŸš¨ ê°œì¸ì •ë³´ ì¹¨í•´ ëŒ€ì‘ ê³„íš

### 1. ì¹¨í•´ ê°ì§€ ë° ì´ˆê¸° ëŒ€ì‘

#### 1.1 ì¹¨í•´ ê°ì§€ ì‹œìŠ¤í…œ

```typescript
// ê°œì¸ì •ë³´ ì¹¨í•´ ê°ì§€
export class DataBreachDetection {
  static async detectPotentialBreach(): Promise<void> {
    const indicators = [
      await this.checkUnauthorizedAccess(),
      await this.checkDataExfiltration(),
      await this.checkSystemIntrusion(),
      await this.checkDataIntegrityIssues(),
    ];

    const suspiciousActivity = indicators.filter(
      (indicator) => indicator.risk > 0.7
    );

    if (suspiciousActivity.length > 0) {
      await this.initiateBreachResponse(suspiciousActivity);
    }
  }

  private static async initiateBreachResponse(
    indicators: BreachIndicator[]
  ): Promise<void> {
    // 1. ì¦‰ì‹œ ë³´ì•ˆíŒ€ ì•Œë¦¼
    await this.alertSecurityTeam(indicators);

    // 2. ì¹¨í•´ ë²”ìœ„ ì¡°ì‚¬ ì‹œì‘
    const breachAssessment = await this.assessBreachScope(indicators);

    // 3. í•„ìš”ì‹œ ì‹œìŠ¤í…œ ê²©ë¦¬
    if (breachAssessment.severity === "critical") {
      await this.isolateAffectedSystems();
    }

    // 4. ì‚¬ê³  ëŒ€ì‘ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
    await this.startIncidentResponse(breachAssessment);
  }
}
```

### 2. ì¹¨í•´ ì‹ ê³  ë° í†µì§€

#### 2.1 72ì‹œê°„ ë‚´ ê°ë…ê¸°ê´€ ì‹ ê³ 

```typescript
// ê°œì¸ì •ë³´ë³´í˜¸ìœ„ì›íšŒ ì‹ ê³  ìë™í™”
export class BreachNotification {
  static async notifyAuthorities(
    breachIncident: BreachIncident
  ): Promise<NotificationResult> {
    // 72ì‹œê°„ ë‚´ ì‹ ê³  ì˜ë¬´ í™•ì¸
    const timeSinceBreach = Date.now() - breachIncident.discoveredAt.getTime();
    const hoursElapsed = timeSinceBreach / (1000 * 60 * 60);

    if (hoursElapsed > 72) {
      logger.error("Breach notification deadline exceeded", {
        breachId: breachIncident.id,
        hoursElapsed,
        deadline: 72,
      });
    }

    // ì‹ ê³ ì„œ ìë™ ìƒì„±
    const notificationReport = await this.generateNotificationReport(
      breachIncident
    );

    // ê°ë…ê¸°ê´€ ì‹ ê³ 
    const submissionResult = await this.submitToAuthorities(notificationReport);

    // ì‹ ê³  ì™„ë£Œ ê¸°ë¡
    await this.recordNotificationSubmission(
      breachIncident.id,
      submissionResult
    );

    return submissionResult;
  }

  private static async generateNotificationReport(
    incident: BreachIncident
  ): Promise<BreachNotificationReport> {
    return {
      incidentId: incident.id,
      discoveryDate: incident.discoveredAt,
      breachType: incident.type,
      affectedDataTypes: incident.affectedDataTypes,
      numberOfAffectedIndividuals: incident.affectedIndividuals.length,
      breachCircumstances: incident.circumstances,
      risksToIndividuals: incident.riskAssessment,
      containmentMeasures: incident.containmentActions,
      preventiveMeasures: incident.preventiveActions,
      contactInformation: {
        dataProtectionOfficer: process.env.DPO_CONTACT,
        organization: "LeoFitTech Co., Ltd.",
      },
    };
  }
}
```

### 3. ì •ë³´ì£¼ì²´ í†µì§€

#### 3.1 ê°œì¸ë³„ ì¹¨í•´ í†µì§€

```typescript
// ì •ë³´ì£¼ì²´ í†µì§€ ì‹œìŠ¤í…œ
export class IndividualNotification {
  static async notifyAffectedIndividuals(
    breachIncident: BreachIncident
  ): Promise<void> {
    for (const individual of breachIncident.affectedIndividuals) {
      try {
        // ê°œì¸ë³„ ìœ„í—˜ë„ í‰ê°€
        const riskLevel = await this.assessIndividualRisk(
          individual,
          breachIncident
        );

        // ë§ì¶¤í˜• í†µì§€ ë©”ì‹œì§€ ìƒì„±
        const notificationMessage = await this.generatePersonalizedNotification(
          individual,
          breachIncident,
          riskLevel
        );

        // ë‹¤ì¤‘ ì±„ë„ í†µì§€ (ì´ë©”ì¼, SMS)
        await this.sendMultiChannelNotification(
          individual,
          notificationMessage
        );

        // í†µì§€ ì™„ë£Œ ê¸°ë¡
        await this.recordIndividualNotification(
          individual.id,
          breachIncident.id
        );
      } catch (error) {
        logger.error("Failed to notify individual about breach", {
          individualId: individual.id,
          breachId: breachIncident.id,
          error,
        });

        // ì‹¤íŒ¨í•œ í†µì§€ëŠ” ìˆ˜ë™ ì²˜ë¦¬ íì— ì¶”ê°€
        await this.addToManualNotificationQueue(
          individual.id,
          breachIncident.id
        );
      }
    }
  }
}
```

---

## ğŸ“‹ ê°œì¸ì •ë³´ ë³´í˜¸ ì •ì±… ë¬¸ì„œ

### 1. ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨ í…œí”Œë¦¿

```markdown
# LeoFitTech ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨

**ì‹œí–‰ì¼ì: 2024ë…„ 1ì›” 1ì¼**
**ê°œì •ì¼ì: 2024ë…„ 9ì›” 19ì¼**

## 1. ê°œì¸ì •ë³´ì˜ ì²˜ë¦¬ ëª©ì 

LeoFitTech('íšŒì‚¬'ë¼ í•¨)ëŠ” ë‹¤ìŒì˜ ëª©ì ì„ ìœ„í•˜ì—¬ ê°œì¸ì •ë³´ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤. ì²˜ë¦¬í•˜ê³  ìˆëŠ” ê°œì¸ì •ë³´ëŠ” ë‹¤ìŒì˜ ëª©ì  ì´ì™¸ì˜ ìš©ë„ë¡œëŠ” ì´ìš©ë˜ì§€ ì•Šìœ¼ë©°, ì´ìš© ëª©ì ì´ ë³€ê²½ë˜ëŠ” ê²½ìš°ì—ëŠ” ê°œì¸ì •ë³´ë³´í˜¸ë²• ì œ18ì¡°ì— ë”°ë¼ ë³„ë„ì˜ ë™ì˜ë¥¼ ë°›ëŠ” ë“± í•„ìš”í•œ ì¡°ì¹˜ë¥¼ ì´í–‰í•  ì˜ˆì •ì…ë‹ˆë‹¤.

### ê°€. í™ˆí˜ì´ì§€ íšŒì›ê°€ì… ë° ê´€ë¦¬

- íšŒì› ê°€ì…ì˜ì‚¬ í™•ì¸, íšŒì›ì œ ì„œë¹„ìŠ¤ ì œê³µì— ë”°ë¥¸ ë³¸ì¸ ì‹ë³„Â·ì¸ì¦, íšŒì›ìê²© ìœ ì§€Â·ê´€ë¦¬, ì„œë¹„ìŠ¤ ë¶€ì •ì´ìš© ë°©ì§€ ëª©ì ìœ¼ë¡œ ê°œì¸ì •ë³´ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.

### ë‚˜. ìƒí’ˆ ë˜ëŠ” ì„œë¹„ìŠ¤ ì œê³µ

- ì„œë¹„ìŠ¤ ì œê³µ, ê³„ì•½ì„œÂ·ì²­êµ¬ì„œ ë°œì†¡, ì½˜í…ì¸  ì œê³µ, ë§ì¶¤ì„œë¹„ìŠ¤ ì œê³µ, ë³¸ì¸ì¸ì¦ì„ ëª©ì ìœ¼ë¡œ ê°œì¸ì •ë³´ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.

### ë‹¤. ê³ ì¶©ì²˜ë¦¬

- ë¯¼ì›ì¸ì˜ ì‹ ì› í™•ì¸, ë¯¼ì›ì‚¬í•­ í™•ì¸, ì‚¬ì‹¤ì¡°ì‚¬ë¥¼ ìœ„í•œ ì—°ë½Â·í†µì§€, ì²˜ë¦¬ê²°ê³¼ í†µë³´ ëª©ì ìœ¼ë¡œ ê°œì¸ì •ë³´ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.

## 2. ê°œì¸ì •ë³´ì˜ ì²˜ë¦¬ ë° ë³´ìœ ê¸°ê°„

â‘  íšŒì‚¬ëŠ” ë²•ë ¹ì— ë”°ë¥¸ ê°œì¸ì •ë³´ ë³´ìœ Â·ì´ìš©ê¸°ê°„ ë˜ëŠ” ì •ë³´ì£¼ì²´ë¡œë¶€í„° ê°œì¸ì •ë³´ë¥¼ ìˆ˜ì§‘ ì‹œì— ë™ì˜ë°›ì€ ê°œì¸ì •ë³´ ë³´ìœ Â·ì´ìš©ê¸°ê°„ ë‚´ì—ì„œ ê°œì¸ì •ë³´ë¥¼ ì²˜ë¦¬Â·ë³´ìœ í•©ë‹ˆë‹¤.

â‘¡ ê°ê°ì˜ ê°œì¸ì •ë³´ ì²˜ë¦¬ ë° ë³´ìœ  ê¸°ê°„ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

### ê°€. ìƒë‹´ ì‹ ì²­ ì„œë¹„ìŠ¤ ì œê³µ

- ë³´ìœ ê·¼ê±°: ê³„ì•½ì´í–‰, ìš”ê¸ˆì •ì‚°, ë¯¼ì›ì²˜ë¦¬ ë“±
- ë³´ìœ ê¸°ê°„: 3ë…„
- ê´€ë ¨ë²•ë ¹: ì „ììƒê±°ë˜ ë“±ì—ì„œì˜ ì†Œë¹„ìë³´í˜¸ì— ê´€í•œ ë²•ë¥ 

### ë‚˜. ë§ˆì¼€íŒ… ë° ê´‘ê³ ì—ì˜ í™œìš©

- ë³´ìœ ê·¼ê±°: ì •ë³´ì£¼ì²´ ë™ì˜
- ë³´ìœ ê¸°ê°„: ë™ì˜ì² íšŒ ì‹œê¹Œì§€ ë˜ëŠ” 2ë…„
- ê´€ë ¨ë²•ë ¹: ê°œì¸ì •ë³´ë³´í˜¸ë²•

## 3. ì •ë³´ì£¼ì²´ì˜ ê¶Œë¦¬Â·ì˜ë¬´ ë° í–‰ì‚¬ë°©ë²•

â‘  ì •ë³´ì£¼ì²´ëŠ” íšŒì‚¬ì— ëŒ€í•´ ì–¸ì œë“ ì§€ ë‹¤ìŒ ê° í˜¸ì˜ ê°œì¸ì •ë³´ ë³´í˜¸ ê´€ë ¨ ê¶Œë¦¬ë¥¼ í–‰ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1. ê°œì¸ì •ë³´ ì²˜ë¦¬í˜„í™© í†µì§€ìš”êµ¬
2. ê°œì¸ì •ë³´ ì—´ëŒìš”êµ¬
3. ê°œì¸ì •ë³´ ì •ì •Â·ì‚­ì œìš”êµ¬
4. ê°œì¸ì •ë³´ ì²˜ë¦¬ì •ì§€ìš”êµ¬

â‘¡ ì œ1í•­ì— ë”°ë¥¸ ê¶Œë¦¬ í–‰ì‚¬ëŠ” íšŒì‚¬ì— ëŒ€í•´ ì„œë©´, ì „í™”, ì „ììš°í¸, ëª¨ì‚¬ì „ì†¡(FAX) ë“±ì„ í†µí•˜ì—¬ í•˜ì‹¤ ìˆ˜ ìˆìœ¼ë©° íšŒì‚¬ëŠ” ì´ì— ëŒ€í•´ ì§€ì²´ì—†ì´ ì¡°ì¹˜í•˜ê² ìŠµë‹ˆë‹¤.

â‘¢ ì •ë³´ì£¼ì²´ê°€ ê°œì¸ì •ë³´ì˜ ì˜¤ë¥˜ ë“±ì— ëŒ€í•œ ì •ì • ë˜ëŠ” ì‚­ì œë¥¼ ìš”êµ¬í•œ ë•Œì—ëŠ” íšŒì‚¬ëŠ” ì •ì • ë˜ëŠ” ì‚­ì œë¥¼ ì™„ë£Œí•  ë•Œê¹Œì§€ ë‹¹í•´ ê°œì¸ì •ë³´ë¥¼ ì´ìš©í•˜ê±°ë‚˜ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

## 4. ê°œì¸ì •ë³´ë³´í˜¸ì±…ì„ì

â‘  íšŒì‚¬ëŠ” ê°œì¸ì •ë³´ ì²˜ë¦¬ì— ê´€í•œ ì—…ë¬´ë¥¼ ì´ê´„í•´ì„œ ì±…ì„ì§€ê³ , ê°œì¸ì •ë³´ ì²˜ë¦¬ì™€ ê´€ë ¨í•œ ì •ë³´ì£¼ì²´ì˜ ë¶ˆë§Œì²˜ë¦¬ ë° í”¼í•´êµ¬ì œ ë“±ì„ ìœ„í•˜ì—¬ ì•„ë˜ì™€ ê°™ì´ ê°œì¸ì •ë³´ë³´í˜¸ì±…ì„ìë¥¼ ì§€ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤.

### ê°œì¸ì •ë³´ë³´í˜¸ì±…ì„ì

- ì„±ëª…: í™ê¸¸ë™
- ì§ì±…: ê°œì¸ì •ë³´ë³´í˜¸ì±…ì„ì
- ì—°ë½ì²˜: privacy@LeoFitTech.co.kr, 02-1234-5678

â‘¡ ì •ë³´ì£¼ì²´ê»˜ì„œëŠ” íšŒì‚¬ì˜ ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•˜ì‹œë©´ì„œ ë°œìƒí•œ ëª¨ë“  ê°œì¸ì •ë³´ ë³´í˜¸ ê´€ë ¨ ë¬¸ì˜, ë¶ˆë§Œì²˜ë¦¬, í”¼í•´êµ¬ì œ ë“±ì— ê´€í•œ ì‚¬í•­ì„ ê°œì¸ì •ë³´ë³´í˜¸ì±…ì„ìì—ê²Œ ë¬¸ì˜í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 5. ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨ ë³€ê²½

ì´ ê°œì¸ì •ë³´ì²˜ë¦¬ë°©ì¹¨ì€ ì‹œí–‰ì¼ë¡œë¶€í„° ì ìš©ë˜ë©°, ë²•ë ¹ ë° ë°©ì¹¨ì— ë”°ë¥¸ ë³€ê²½ë‚´ìš©ì˜ ì¶”ê°€, ì‚­ì œ ë° ì •ì •ì´ ìˆëŠ” ê²½ìš°ì—ëŠ” ë³€ê²½ì‚¬í•­ì˜ ì‹œí–‰ 7ì¼ ì „ë¶€í„° ê³µì§€ì‚¬í•­ì„ í†µí•˜ì—¬ ê³ ì§€í•  ê²ƒì…ë‹ˆë‹¤.
```

---

## ğŸ” ê²°ë¡  ë° ê¶Œì¥ì‚¬í•­

### 1. í•µì‹¬ ì¤€ìˆ˜ ì‚¬í•­

1. **íˆ¬ëª…ì„± ì›ì¹™**: ëª¨ë“  ê°œì¸ì •ë³´ ì²˜ë¦¬ í™œë™ì„ ëª…í™•íˆ ê³µê°œ
2. **ìµœì†Œ ìˆ˜ì§‘ ì›ì¹™**: ì„œë¹„ìŠ¤ ì œê³µì— í•„ìš”í•œ ìµœì†Œí•œì˜ ì •ë³´ë§Œ ìˆ˜ì§‘
3. **ëª©ì  ì œí•œ ì›ì¹™**: ìˆ˜ì§‘ ëª©ì  ì™¸ ìš©ë„ë¡œ ì‚¬ìš© ê¸ˆì§€
4. **ì •í™•ì„± ì›ì¹™**: ê°œì¸ì •ë³´ì˜ ì •í™•ì„±ê³¼ ìµœì‹ ì„± ìœ ì§€
5. **ì•ˆì „ì„± ì›ì¹™**: ê¸°ìˆ ì Â·ê´€ë¦¬ì  ë³´í˜¸ì¡°ì¹˜ êµ¬í˜„

### 2. ì§€ì†ì  ê°œì„  ë°©ì•ˆ

1. **ì •ê¸° êµìœ¡**: ì§ì› ëŒ€ìƒ ê°œì¸ì •ë³´ë³´í˜¸ êµìœ¡ ì‹¤ì‹œ
2. **ëª¨ë‹ˆí„°ë§ ê°•í™”**: ê°œì¸ì •ë³´ ì²˜ë¦¬ í˜„í™© ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
3. **ê¸°ìˆ  ì—…ë°ì´íŠ¸**: ìµœì‹  ë³´ì•ˆ ê¸°ìˆ  ë„ì… ë° ì ìš©
4. **ê°ì‚¬ ì²´ê³„**: ë‚´ë¶€ ê°ì‚¬ ë° ì™¸ë¶€ ì¸ì¦ ì·¨ë“
5. **ë²•ë ¹ ì¤€ìˆ˜**: ê´€ë ¨ ë²•ë ¹ ë³€ê²½ì‚¬í•­ ëª¨ë‹ˆí„°ë§ ë° ëŒ€ì‘

### 3. ë¹„ìƒ ëŒ€ì‘ ì²´ê³„

1. **24ì‹œê°„ ëŒ€ì‘íŒ€**: ê°œì¸ì •ë³´ ì¹¨í•´ ì‹ ê³  ë° ëŒ€ì‘
2. **ìë™í™” ì‹œìŠ¤í…œ**: ì¹¨í•´ ê°ì§€ ë° ì´ˆê¸° ëŒ€ì‘ ìë™í™”
3. **ë³µêµ¬ ê³„íš**: ë°ì´í„° ë°±ì—… ë° ë³µêµ¬ ì ˆì°¨ ìˆ˜ë¦½
4. **ì†Œí†µ ì²´ê³„**: ê³ ê°, ë‹¹êµ­, ë¯¸ë””ì–´ ëŒ€ì‘ ë§¤ë‰´ì–¼

ì´ ì„¤ê³„ ë¬¸ì„œë¥¼ ê¸°ë°˜ìœ¼ë¡œ LeoFitTechëŠ” ê³ ê°ì˜ ê°œì¸ì •ë³´ë¥¼ ì•ˆì „í•˜ê³  íˆ¬ëª…í•˜ê²Œ ë³´í˜¸í•˜ë©°, ê´€ë ¨ ë²•ë ¹ì„ ì¤€ìˆ˜í•˜ëŠ” ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
